---
title: COA Review (1)
date: 2022-02-15 16:08:03
description: 南京大学2021秋季学期《计算机组织与结构》课程笔记(1)
top_img: https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/miku26.jpg
tags:
   - 计算机组织与结构
   - Software Engineering
   - Computer Science
   - Computer Organization and Architecture
categories:
   - 软件工程
   - 计算机组织与结构
---


## 1 计算机系统概述

### What is computer

​	计算机是指<span style='color: red'>**通用电子数字计算机**</span>（general-purpose electronic digital computer）

* **通用**：不是一种专用设备
	* 所有计算机在给予足够时间和容量存储器的条件下，都可以完成同样的计算
	* 当希望完成新的计算时，不需要对计算机重新设计
* **电子**（非机械）：采用电子元器件
* **数字**（非模拟）：信息采用数字化的形式表示

<!--more-->

***



### Organization and Architecture

1. <span style='color: orange'>**组织**</span>（Organization）：对编程人员不可以见
	* 操作单元及其相互连接
	* 包括：控制信号，存储技术，$\dots$
		* 例如：实现乘法是通过硬件单元还是重复加法（how to implement multiplication，编程人员不需要知道如何实现，只需要知道有加法这个东西，封装的实现就是**组织**）
2. <span style='color: orange'>**结构**</span>（Architecture）：对编程人员可见
	* 直接影响程序逻辑执行的属性
	* 包括：指令集，表示数据类型的位数，$\dots$
		* 例如：是否有乘法指令（是否有某种功能的接口，编程人员需要知道有这种接口才可以调用这种功能，这种就是**结构**）

***



### History of computer

#### 第一代 真空管（1946-1957）

1. ENIAC（1946-1955）：第一台通用计算机，十进制，手动编程

2. ABC（1937）：世界上第一台计算机，不可编程

3. EDVAC：<span style='color: red'>**冯·诺依曼结构**</span>

	>  冯诺依曼结构
	>
	>  又称为“普林斯顿结构"
	>
	>  三个**基本原则**：
	>
	>  1. 二进制
	>  2. 存储程序
	>  3. 5个组成部分
	>  	* 主存储器（存储单元）：地址和存储的内容
	>  	* 算术逻辑单元（处理单元）：执行信息的实际处理
	>  	* 程序控制单元（控制单元）：指挥信息的处理
	>  	* 输入设备：将信息送入计算机中
	>  	* 输出设备：将处理结果以某种形式显示在计算机外



#### 第二代 晶体管（1958-1964）



#### 第三代及后续几代：集成电路（1965-现在）

思想：

* 将整个电路安装在很小的硅片上，而不是用分立元件搭成的等价电路

* 这些晶体管可以通过金属化过程相互连接，以形成电路

***



### Moore‘s Law

<span style='color: red'>**摩尔定律**</span>：单芯片上所能包含的晶体管数量每年翻一番，1970年起减慢为每18个月翻一番

影响：

1. 更小的尺寸带来更多灵活性和可能性
2. 由于单个芯片的成本几乎不变，计算机逻辑电路和存储电路的成本显著下降
3. 减小了对电能消耗和冷却的要求
4. 集成电路上的内部连接比焊接更可靠，芯片间的连接更少

***



### Computer Performance

计算机的关键参数之一：性能，成本，尺寸，安全性，可靠性，能耗

性能评价标准：

* CPU：速度
* 存储器：速度，容量
* I/O：速度，容量
* $\dots$

> **计算机设计的主要目标是：提高CPU性能**

***



### CPU Performance

#### 系统时钟

1. <span style='color: red'>**时钟频率**</span> / 时钟速度（单位：Hz）：计算机在单位时间内（例如1秒钟）执行的最基本操作的次数
2. <span style='color: red'>**时钟周期**</span> / 周期时间（单位：s）：执行每次最基本操作的时间
	* 时钟滴答（有时也称为“**时钟周期**”）：CPU中用于同步执行最基本操作的单个单子脉冲
	* 因此，周期时间即为两个电子脉冲之间的时间

#### 指令执行

1. 处理器由时钟驱动，时钟具有固定的频率 $f$，或等价为固定的时钟周期 $t$

2. 如果用 $CPI_i$ 来表示执行指定类型 $i$ 指令所需要的周期数，用 $I_i$ 表示在某一给定程序中所执行的 $i$ 类指令的条数，则可以计算整个的 $CPI$ 如下：
	$$
	CPI = \frac{\sum_{i=1}^n(CPI_i \times I_i)}{I_c},  I_c = \sum_{i=1}^n I_i
	$$

	> $CPI$：Cycle per Instruction, 执行每条指令平均需要的时钟周期

3. 执行一个给定程序的处理时间表示为：
	$$
	T = I_c \times CPI \times t \\
	T = I_c \times [p + (m \times k)] \times t
	$$

	> $p$：译码和执行指令的时间
	>
	> $m$：存储器访问次数
	>
	> $k$：存储器周期时间和处理器周期时间之比
	>
	> $(m \times k) \times t$：在处理器和存储器之间传输数据
	>
	> $t$：时钟周期

![](https://s2.loli.net/2022/01/05/uB5cEFsZYbnyO6C.jpg)



* 每秒百万条指令（MIPS）：
	$$
	MIPS = \frac{I_c}{T \times 10^6} = \frac{f}{CPI \times 10^6}
	$$

* 每秒百万条浮点操作（MFLOPS）：
	$$
	MFLOPS = \frac{N_{floating-point\ op}}{T \times 10^6}
	$$

#### 基准程序

1. 使用一系列基准程序来测量系统的性能
2. 平均结果
	* 算术平均值：$R_A = \frac{1}{m} \sum_{i=1}^n R_i$
	* 调和平均值：$R_H = \frac{m}{\sum_{i=1}^m \frac{1}{R_i}}$



## 2 计算机的顶层视图

> 冯诺依曼结构：存储单元，处理单元，控制单元，输入，输出

### Computer Top-Level Structure

![](https://s2.loli.net/2022/01/05/SmqGyjigoExI3fz.png)

![](https://s2.loli.net/2022/01/05/OnptjymW9KikMXF.png)

***



### How Computer Works

1. 指令和数据存储在单个读写存储器中

2. 主存中的内容按位置访问，**无需考虑其中包含的类型**

	> 位置：地址，存储的内容可以是数据也可以是指令也可以是地址

3. CPU从一条指令到下一条指令以**顺序**方式执行（除非明确修改）

4. I/O模块与CPU、主存交换计算机系统外部的数据

	> 冯·诺依曼结构中的输入输出指的就是I/O模块，而不是外部设备

***



### CPU

1. CPU从一条指令到下一条指令以顺序方式执行（除非明确修改）
2. 指令和数据存储在单个读写存储器中
3. 主存中的内容按位置访问，无需考虑其中包含的类型



#### Q1：CPU的频率能不能无限提高

1. 理论限制
	* mos管开关、脉冲通过门电路需要时间
	* 为了信号同步，每个脉冲信号需要持续一定的时间
	* $\dots$
2. 制造限制
	* 芯片面积越来越大，导致连线延迟越来越大，需要保证信号在设计指定时钟周期内从芯片的一角到达另一角
	* 频率越高（即mos管的开关频率也越高）会导致开关损耗也越高，cpu会费电和散热高
3. 解决：指令流水线，控制器，多核等



#### Q2：内存墙的存在

主存和CPU之间传输数据的速度跟不上CPU处理数据的速度（CPU发展速度远远快与主存发展的速度）

解决方法：采用高速缓存（Cache）

1. 添加一级或多级缓存以减少存储器访问频率并提高数据传输速率
2. 增大总线的数据宽度，来增加每次所能取出的位数



#### Q3：CPU等待I/O传输数据

CPU在等待I/O设备时保持空闲

解决方法：<span style='color: red'>**中断**</span>：其他模块（例如I/O）可以中断正常处理顺序的机制。将中断周期加入指令周期

***



### Memory

1. 指令和数据存储在单个读写存储器中
2. 主存中的内容按位置访问，无需考虑其中包含的类型



#### Q4：兼顾存储容量、速度和陈本

* 约束

	* 容量：越大越好
	* 速度：跟上存储器处理数据的速度
	* 成本：相对于其他组件合理

* 约束之间的关系

	* 更短的访问时间，更高的每bit成本

* 解决方法：层次式存储结构（存储金字塔）

	* 需求：
		* 大容量数据存储
		* 高速性能
	* 解决方案：使用存储器层次结构而不是依赖单个存储器组件

	![](https://s2.loli.net/2022/01/05/Jvq1Pi7WMhnrHyD.png)

***



### I/O

与CPU和内存交换从外部来源收集的数据（注意外部设备不能算是I/O中的东西，I/O指的是I/O模块，负责控制和传输）

#### Q5：I/O设备传输速率差异大

I/O性能跟不上CPU速度的提升

解决方法：采用缓冲区和改进I/O操作技术

***



### Bus（总线）

总线时连接两个或多个设备的通信道路



#### Q6：计算机部件互联复杂

解决方案：采用总线

数据传输类型

* 控制线：控制数据线和地址线的访问和实用
* 地址线：指定数据总线和地址I/O端口上数据的来源或去向
* 数据线：在系统模块之间传送数据

***



## 3 数据的机器级表示

### 信息的二进制编码

在冯·诺依曼结构中，所有信息（指令和数据）都采用二进制编码

* **编码**：用少量简单的基本符号对复杂多样的信息进行一定规律的组合
* <span style='color: red'>**采用二进制的原因**</span>
	* 多种物理器件可以表示两种稳定的状态，用于表示二进制中的$0$ 和 $1$ 
	* 二进制的编码和运算规则简单
	* $0$ 和 $1$ 可以对应逻辑命题中的 “真” 和 “假”
* $K$ 位的二进制编码**至多**表示 $2^K$ 个不同的值（无论是什么类型的数据都遵循这个规则）

***



### 整数的二进制表示

1. 无符号整数
2. 有符号整数：原码，反码，移码，补码
	* 原码、反码、移码在进行加法运算时都会造成不必要的硬件需求，因此目前计算机中普遍使用补码
	* 二进制补码的运算
	* 二进制 - 十进制的转换



#### 补码表示法

相比原码表示法的优势：无论同号还是异号都可以直接相加

表示：正数与原码相同，负数在对应原码的基础上**“取反加一”**

1. 000...000 ~ 011...111：表示的值不变，与原码相同

2. 100...000 ~ 111...111：表示的值由原来的$2^{k-1} \sim 2^{k} - 1$ 变为 $2^{k-1} \sim -1$ （平移）

	> 真值由原来的无符号数对应的真挚减去 $2^k$，取反加一的由来



#### 补码的真值

$$
[X]_c = X_nX_{n-1} \dots X_2X_1 \\
X = -X_n \times 2^{n-1} + X_{n-1} \times2^{n-2} + \dots + X_2 \times 2^1 + X_1 \times 2^0
$$

值的范围：$-2^{n-1} \le X \le 2^{n-1} - 1$

***



### 浮点数的二进制数表示

1. 实数表示

2. **定点表示法**表示值的范围是有限制的

3. 科学计数法：
	$$
	\pm S \times B^E
	$$

	> $\pm$：符号，正或负
	>
	> $S$：尾数/有效值
	>
	> $B$：基/底，对所有数都是相同的，不需要存储的（隐含的）
	>
	> $E$：阶码/指数



#### 规格化数

**规格化表示**：
$$
\pm 1.bbb\dots b \times 2^E
$$

* 符号总是位于字的第一位

* 尾数（$S$）的第 $1$ 位总是 $1$，不需要存入尾数字段中（默认省略）

* 阶码（$E$）的真实值加上 $127$ 后，再存入阶码字段中（移码）

	> 假设阶码位数为$e$，则偏移量计算如下：
	> $$
	> bias = 2^{e-1} - 1
	> $$

* 底（$B$）默认为2



**值的范围（未引入非规格化数的情况下）**

* 介于 $-(2 - 2^{-23}) \times 2^{128}$  和 $-2^{-127}$ 之间的负数
* 介于 $2^{-127}$ 和 $(2 - 2^{-23}) \times 2^{128}$ 之间的正数

![](https://s2.loli.net/2022/01/05/KBuJL6dFEGQa2xI.png)



**规格化数的变化**

对于一定长度的规格化数，表示范围和精度之间存在权衡

1. 增加阶码位数：扩大表示范围，降低表示精度
2. 增加尾数尾数：提高表示精度，减少表示范围
3. 采用更大的底：实现更大的范围，降低表示的精度



#### 非规格化数

* 处理规格化数中的下溢情况
* 当结果的阶值太小时，通过右移进行非规格化；每次右移阶值增，直到阶值落在可表示范围内

![](https://s2.loli.net/2022/01/05/CAUHGnoa5W1ih89.png)



#### IEEE754标准

![](https://s2.loli.net/2022/01/05/phPBFnNWGm3CUt2.png)

![](https://s2.loli.net/2022/01/05/YoKFkXRCP6vMeaU.png)

***



### 二进制编码表示的十进制数表示

* 浮点运算的问题：精度限制、转换成本高
* 应用需要：长数字串的计算
* 解决方法：用 $4$ 位<span style='color: red'>**二进制编码十进制**</span>（BCD）表示 $0, 1, 2, \dots , 9$ 直接计算



#### NBCD码

1. $0 \sim 9$：$0000 \sim 1001$
2. 符号：使用四个最高有效位
	1. 正：$1100/0$
	2. 负：$1101/1$

***



## 4 数据校验码

### 差错（Error）

* 数据在计算机内部进行计算 、 存取和传送过程中 由于元器件故障
	或噪音干扰等原因 会出现差错
* 以存储为例
	* 硬故障（hard failure）： 永久性的物理故障，以至于受影响的存储单元不能可靠地存储数据，成为固定的 $1$ 或 $0$ 故障或者在 $0$ 和 $1$ 之间不稳定地跳变
		* 由恶劣的环境 、制造缺陷和旧损引起
	* 软故障 （soft error）：随机非破坏性事件，它改变了某个或某些存储单元的内容 但没有损坏机器
		* 由电源问题或 α 粒子引起
* 解决方案
	* 从计算机硬件可靠性入手，在电路 、电源 、布线等方面采取必要的措施，提高计算机的抗干扰能力
	* 采取数据检错和校正措施，自动发现并纠正错误

***



### 纠错（Error Correction）

* 基本思想：存储额外的信息以进行检错和校正

* 处理过程

	* 数据输入：使用函数 $f$ 在 $M$ 位数据 $D$ 上生成 $K$ 位的校验码 $C$

	* 数据输出：使用函数 $f$ 在 $M$ 位数据 $D'$ 上生成新的 $K$ 位校验码 $C''$，并与取出的 $K$ 位校验码 $C'$ 进行比较

		> 注意这里的 $C$ 不一定等于 $C'$，因为在数据存储的过程中校验码也有可能变化，所以我们进行比较的其实是**取出后**的校验码和将取出后的数据经过计算得到的校验码来判断是否有出错。
		>
		> 我们可以考虑一种特殊情况：如果在存储过程中数据和校验码同时出错，且数据出错后计算得到的校验码刚好是校验码出错后的结果，那么这种纠错就会失去作用。
		>
		> 不过幸运的是，在这里我们都假设只有一位会出错（无论数据还是校验码）。

		* 没有检测到差错：使用数据 $D'$ （$D'$ 可能不等于 $D$）
		* 检测到差错并且可以校正：校正数据 $D'$ 来生成数据 $D''$，并用数据 $D''$
		* 检测到差错但无法纠正：报告

![](https://s2.loli.net/2022/01/05/HNOhuwPBq8ML31Q.png)

***



### 奇偶校验码

**基本思想**：增加一位校验码来表示数据中 $1$ 的数量是奇数还是偶数

**处理过程**：

1. 假设数据为 $D = D_M \dots D_2D_1$
2. 数据输入（奇校验的数据加入校验码后有奇数个 $1$，偶校验相反）
	* 奇校验：$C = D_M \oplus \dots \oplus D_2 \oplus D_1 \oplus 1$
	* 偶校验：$C = D_M \oplus \dots \oplus D_2 \oplus D_1$
3. 数据输出
	* 奇校验：$C'' = D'_M \oplus \dots \oplus D'_2 \oplus D'_1 \oplus 1$
	* 偶校验：$C'' = D'_M \oplus \dots \oplus D'_2 \oplus D'_1$
4. 检错：$S = C'' \oplus C'$
	* $S = 0$：正确 / 数据中出错的位数为偶数
	* $S = 1$：数据中心出错的位数为奇数

**优点**：代价低，只需要1位额外数据，计算简单

**缺点**：

1. 不能发现出错位数为偶数的情形
2. 发现错误后不能校正



### 海明码

**基本思想**：将数据分成几组，对每一组都使用奇偶校验码进行检错

**处理过程**：

1. 将 $M$ 位数据分成 $K$ 组
2. 数据输入：为数据 $D$ 中每组生成 $1$ 位校验码，合并得到 $K$ 位校验码 $C$
3. 数据输出：为数据 $D'$ 中每组生成 $1$ 位校验码，合并得到新的 $K$ 位校验码 $C''$
4. 检错：将校验码 $C''$ 和取出的校验码 $C''$ 按位进行异或，生成 $K$ 位<span style='color: red'>**故障字（syndrome word）**</span>

**校验码长度**

> 假设最多 $1$ 位发生错误，数据的长度为 $M$，校验码长度为 $K$

可能的情况：

* 数据中有一位出现错误：$M$
* 校验码中有一位出现错误：$K$
* 没有出现错误：$1$

**校验码长度**：
$$
2^K \ge M + K + 1
$$


#### 故障字

故障字的每种取值都反映一种情形（数据出错 / 校验码出错 / 未出错）

**规则**：

1. 全都是0：没有检测到错误
2. 有且仅有1位是1：错误发生在校验码中的某一位，不需要纠正
3. 有多位为1：错误发生在数据中的某一位，将 $D'$ 中对应数据位取反即可纠正（得到$D''$）

> 将位设置在与其故障字值相同的位置

![](https://s2.loli.net/2022/01/05/L3pa76GrimFzTlb.png)



### 循环冗余校验（Cyclic Redundancy Check, CRC）

> * 适用于以流格式存储和传输大量数据
>
> * 用数学函数生成数据和校验码之间的关系

**基本思想**：

1. 假设数据有 $M$ 位，左移数据 $K$ 位（右侧补 $0$），并用 $K+1$ 位<span style='color: red'>**生成多项式**</span>除它（模 $2$ 运算）
2. 采用 $K$ 位余数作为校验码
3. 把校验码放在数据（不含补的0）后面，一同存储或传输

**校错**：

1. 如果 $M+K$ 位内容可以被生成多项式除尽，则没有检测到错误
2. 否则，发生错误



#### 模2运算

规则：有一落一，没一落零，做异或运算。



## 5 整数运算

### 算术逻辑单元（ALU）

算术逻辑单元是计算机实际完成数据算术逻辑运算的部件

1. 数据由寄存器（registers）提交给ALU，运算结果也存于寄存器
2. ALU可能根据运算结果设置一些标志（Flags），标志值也保存在处理器内的寄存器中
3. 控制器（Control unit）提供控制ALU操作和数据传入送出ALU的信号

***



### 加法

#### 全加器

1. 与门延迟：1ty
2. 或门延迟：1ty
3. 异或门延迟：3ty

**基本思想**：第 $i$ 位加法
$$
S_i = X_i \oplus Y_i \oplus C_{i-1} \\
C_i = X_iC_{i-1} + Y_iC_{i-1} + X_iY_i
$$
![](https://s2.loli.net/2022/01/05/uM783myYlLTNcUb.png)

#### 串行进位加法器

**延迟**：
$$
C_n = 2n\ ty \\
S_n = (2n+1)\ ty
$$

> 计算 $S_1$ 时，不需要等待 $C_0$，直接计算 $X_1 \oplus Y_1 \oplus C_0$，需要6ty的延迟
>
> 计算 $S_2$ 时，$C_1$ 的延迟是 2ty（按照公式），但此时 $X_2 \oplus Y_2$ 还没算完（需要3ty的延迟），所以仍然不需要等待 $C_1$，此时仍然只需要 6ty 的延迟
>
> 其余时刻，由于计算 $S_n$ 的时候需要等待 $C_{n-1}$ ，在等待过程中可以先把 $X_{n} \oplus Y_{n}$ 算好，因此只需要在 $2n-2$ 的基础上（计算 $C_{n-1}$ 的延迟）再加上异或门的时间（3ty），因此$S_n = (2n+1)\ ty$



#### 全先行进位加法器（CLA）

定义两个辅助函数：

1. $P_i = X_i + Y_i$
2. $G_i = X_iY_i$

**延迟：6ty**

> 1. 先求所有的 $P_i$ 和 $G_i$，需要 1ty（并行求）
> 2. 再求所有的 $C_n$，需要2ty。 $C_i = P_iC_{i-1} + G_i$
> 3. 再与 $X_n \oplus Y_n$ 的结果进行异或，因为前面两个的延迟和是3ty，所以 $X_n \oplus Y_n$ 也同步完成，这里直接进行异或即可



#### 部分先行加法器

思路：采用多个CLA并将其串联，取得计算时间和硬件复杂度之间的权衡。

![](https://s2.loli.net/2022/01/05/4sofz1GrdRnxO2w.png)

延迟：12ty

> 首先计算所有CLA中的 $P_i$ 和 $G_i$，需要 1ty，然后计算第一个CLA中的 $C_n$，需要2ty，同时在这 3ty 中同步计算所有CLA中的 $X_i \oplus Y_i$，然后$C_8$ 传到第二个CLA中，第二个CLA计算 $C_n$，需要 2ty，第三个同理，同时在这4ty的延迟中，第一个CLA已经计算好了 $X_i \oplus Y_i \oplus C_{i-1}$ 。然后到最后一个CLA，同理计算 $C_n$，然后计算 $X_i \oplus Y_i \oplus C_{i-1}$，同步进行的还有第二个和第三个CLA的计算 $X_i \oplus Y_i \oplus C_{i-1}$。（可以将四个CLA的计算 $X_i \oplus Y_i \oplus C_{i-1}$ 看成同步进行的）



#### overflow

$$
X_n = Y_n \land S_n \ne X_n, Y_n: overflow = X_nY_n\overline{S_n} + \overline{X_n}\overline{Y_n}S_n \\
C_n \ne C_{n-1}:overflow = C_n \oplus C_{n-1}
$$

### 减法

溢出与加法相同

![](https://s2.loli.net/2022/01/05/OPXCvVJl86ZMN27.png)



### 乘法

**计算机乘法的改进**

* 每一步都计算部分积求和结果
* 右移部分积代替左移部分积
* 若 $Y_i = 0$，只执行移位操作

**问题**：$[X \times Y]_c \ne [X]_c \times [Y]_c$



#### 布斯乘法

**推导：**

![20220105203056.png](https://s2.loli.net/2022/01/05/qrsguzwHRNIBJcT.png)

**布斯乘法**

1. 增加 $Y_0 = 0$
2. 根据 $Y_i - Y_{i+1}$，决定是否增加 $+X, -X, +0$
3. 右移部分积（**右移补充的是符号位**）
4. 重复步骤2和步骤3 $n$ 次，得到最终结果

***



### 除法

**不同情形的处理**

* 若被除数为0，除数不为0：商为0
* 若被除数不为0，除数为0：发生“除数为0”异常
* 若被除数、除数均为0，发生“除法错”异常
* 其余情况进行进一步的除法运算



**手工演算除法**

* 在被除数的左侧补充符号位，将除数的最高位与被除数的次高位对齐
* 从被除数中减去除数，若**够减**，则上商为1；若**不够减**，则上商为0
* 右移除数，重复上述步骤



**改进**

1. 右移除数编程左移余数/商
2. 余数和商放在一个长度为 $2n$ 的寄存器中



**如何判断够减**：余数是否足够大

* 如果余数和除数的符号相同：减法
* 如果余数和除数的符号不同：加法

![](https://s2.loli.net/2022/01/05/pu3fFVXKBUnaxeC.png)



#### 恢复余数除法

**步骤过程**

1. 通过在被除数前面加 $n$ 位**符号扩展**被除数，并存储在余数寄存器和商寄存器中
2. 将余数和商左移，判断是否够减
	* 如果“够”，则做减法（同号）或加法（异号），并上商为0
	* 如果“不够”，则上商为0，并恢复余数
3. 重复以上步骤
4. 如果除数和被除数不同号，则将商替换为其**相反数**（商和被除数须同号）
5. 余数存在余数寄存器中



#### 不恢复余数除法

**大致思路**：不恢复余数，只考虑减法

* 如果余数 $R_i$ 足够大： $R_{i+1} = 2R_i - Y$
* 如果余数 $R_i$ 不够大： $R_{i+1} = 2(R_i +Y) - Y = 2R_i + Y$



**步骤过程**

1. 通过在被除数前面加 $n$ 位**符号扩展**被除数，并存储在余数寄存器和商寄存器中
2. 如果除数和被除数符号相同，则做减法；否则，做加法
	* 如果余数和除数符号相同，则商 $Q_n = 1$，否则 $Q_n = 0$
3. 如果余数和除数符号相同，$R_{i+1} = 2R_i - Y$；否则，$R_{i+1} = 2R_i + Y$
	* 如果新的余数和除数符号相同，使商为1，否则，使商为0
4. 重复第三步
5. 左移商
	* 如果商是负的（被除数和除数的符号不同），商加1
6. 余数和被除数符号不同，修正余数
	* 若被除数和除数符号相同，最后余数加除数；否则，最后余数减除数



## 6 浮点数运算

### 加法和减法

**步骤过程**

1. 检查0
2. 对齐有效值（小阶对大阶）
3. 加或减有效值
4. 规格化结果

![](https://s2.loli.net/2022/01/05/MsLGdT9JltfPBmy.png)

#### 溢出

1. 阶值上溢
	* 正阶值超过可能的最大允许阶值
	* 标记为 $+ \infin$ 或者 $- \infin$
2. 阶值下溢
	* 负阶值小于可能的最小允许阶值
	* 报告为0
3. 有效值上溢
	* 同符号的两个有效值相加可能导致最高有效位的进位
	* 通过重新对齐来修补
4. 有效值下溢
	* 在有效值对齐过程中，可能有数字被移出右端最低位而丢失
	* 需要某种形式的四舍五入（保护位）



#### 原码加法

如果两个操作数有相同的符号，做加法；否则，做减法

1. 做加法：直接相加
	* 如果最高位有进位，则溢出
	* 符号和被加数（被减数）相同
2. 做减法：加第二个操作数的补数
	* 如果最高位有进位，正确（符号与被减数相同）
	* 否则，计算它的补码（符号与被减数相反）



### 乘法

* 无论哪个操作数是0，乘积即为0
* 从阶值的和中减去一个偏移量（$e = e_x + e_y - bias$）
* 有效值相乘
* 结果的规格化和舍入处理
	* 规格化可能导致阶值下溢

![](https://s2.loli.net/2022/01/05/t2KakRxJuCXZFef.png)

### 除法

* 如果除数为0，则报告出错，或将结果设置为无穷大
* 如果被除数是0，则结果是0
* 被除数的阶值减除数的阶值，加上偏移量（$e = e_x - e_y + bias$）
* 有效值相除
* 结果规格化和舍入处理

![](https://img-bed-1309306776.cos.ap-shanghai.myqcloud.com/img/image-20220105213331445.png)

### 精度考虑

**保护位：**

* 寄存器的长度几乎总是大于有效值位长与一个隐含位之和
* 寄存器包含的这些附加位，称为**保护位**
* 保护位用0填充，用于扩充有效值的右端

**舍入**

* 对有效值操作的结果通常保存在更长的寄存器中
* 当结果转换回浮点格式时，必须要去掉多余的位
	1. 就近舍入：结果被舍入成最近的可表示的数
	2. 朝 $+ \infin$ 舍入：结果朝正无穷大方向向上舍入
	3. 朝 $-\infin$ 舍入：结果朝负无穷大方向向下舍入
	4. 朝 $0$ 舍入：结果朝 $0$ 舍入



## 7 二进制编码的十进制数运算

### 加法

相加结果如果大于10，需要再加6来进位

1. 10 ~ 15之间，不够进位，需要补6,
2. 16 ~ 19 之间，已经进位，多减了6，需要补充一个6

### 减法

> 参照补码减法，避免借位

#### 反转数字

> 参照补码的取反加一。有两种方法进行“取反”

* 按位反转，然后添加“1010”
* 添加“0110”，并按位反转

![](https://s2.loli.net/2022/01/05/TrzUGce3EfBDjgN.png)



**结果调整**

1. 如果有进位，舍弃进位，正确
2. 如果没有进位，说明不够减，则对结果按位反转之后加一，并将结果符号取反